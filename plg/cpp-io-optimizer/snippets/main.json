{
    "Optimize IO": {
        "prefix": "int main()",
        "body": [
            "int main() {",
            "\tstd::ios::sync_with_stdio(false);",
            "\tstd::cin.tie(nullptr);", 
            "\tstd::cout.tie(nullptr);",
            "\t$0",
            "}"
        ],
        "description": "Add C++ IO optimization settings"
    },
    "QuickSort Function": {
        "prefix": "void QuickSort",
        "body": [
            "void QuickSort(int* a, int l, int r)",
            "{",
            "\tint i = l;",
            "\tint j = r;",
            "\tint mid = (a[l] + a[r]) / 2;",
            "",
            "\twhile (i <= j)",
            "\t{",
            "\t\twhile(a[i] < mid)",
            "\t\t{",
            "\t\t\ti++;",
            "\t\t}",
            "\t\twhile(a[j] > mid)",
            "\t\t{",
            "\t\t\tj--;",
            "\t\t}",
            "\t\tif (i <= j)",
            "\t\t{",
            "\t\t\tstd::swap(a[i], a[j]);",
            "\t\t\ti++;",
            "\t\t\tj--;",
            "\t\t}",
            "\t}",
            "\tif (l < j)",
            "\t{",
            "\t\tQuickSort(a, l, j);",
            "\t}",
            "\tif (r > i)",
            "\t{",
            "\t\tQuickSort(a, i, r);",
            "\t}",
            "}"
        ],
        "description": "QuickSort implementation for integer array"
    },
    "Binary Search Tree": {
        "prefix": "struct BST",
        "body": [
            "struct Node {",
            "\tint data;",
            "\tNode* right;",
            "\tNode* left;",
            "};",
            "struct BST {",
            "\tNode* root = nullptr;",
            "",
            "\tvoid Push(Node*& root, int data) {",
            "\t\tif (root == nullptr) {",
            "\t\t\tNode* new_node = new Node;",
            "\t\t\t(*new_node).data = data;",
            "\t\t\t(*new_node).left = nullptr;",
            "\t\t\t(*new_node).right = nullptr;",
            "\t\t\troot = new_node;",
            "\t\t}",
            "\t\telse {",
            "\t\t\tif (data < (*root).data) {",
            "\t\t\t\tPush(root->left, data);",
            "\t\t\t} else if (data > (*root).data) {",
            "\t\t\t\tPush(root->right, data);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid Pop(Node*& root, int data) {",
            "\t\tif (root == nullptr) {",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tif (data < (*root).data) {",
            "\t\t\tPop((*root).left, data);",
            "\t\t}",
            "\t\telse if (data > (*root).data) {",
            "\t\t\tPop((*root).right, data);",
            "\t\t}",
            "\t\telse if (data == (*root).data) {",
            "\t\t\tif ((*root).left == nullptr && (*root).right == nullptr) {",
            "\t\t\t\tdelete root;",
            "\t\t\t\troot = nullptr;",
            "\t\t\t}",
            "\t\t\telse if ((*root).left == nullptr) {",
            "\t\t\t\tNode* del_root = root;",
            "\t\t\t\troot = (*root).right;",
            "\t\t\t\tdelete del_root;",
            "\t\t\t}",
            "\t\t\telse if ((*root).right == nullptr) {",
            "\t\t\t\tNode* del_root = root;",
            "\t\t\t\troot = (*root).left;",
            "\t\t\t\tdelete del_root;",
            "\t\t\t}",
            "\t\t\telse {",
            "\t\t\t\tNode* new_root = root->right;",
            "\t\t\t\twhile ((*new_root).left != nullptr) {",
            "\t\t\t\t\tnew_root = (*new_root).left;",
            "\t\t\t\t}",
            "\t\t\t\t(*root).data = (*new_root).data;",
            "\t\t\t\tPop((*root).right, (*new_root).data);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "Binary Search Tree implementation with Push and Pop methods"
    },
    "Stack Implementation": {
        "prefix": "struct Stack",
        "body": [
            "struct Node {",
            "\tint data;",
            "\tNode *next;",
            "};",
            "",
            "struct stack {",
            "\tNode *header = nullptr;",
            "",
            "\tvoid push(int num) {",
            "\t\tNode *new_node = new Node;",
            "\t\tnew_node->data = num;",
            "\t\tnew_node->next = header;",
            "\t\theader = new_node;",
            "\t}",
            "",
            "\tvoid pop() {",
            "\t\tNode *last_node = header;",
            "\t\tNode *new_last_node = last_node->next;",
            "\t\theader = new_last_node;",
            "\t\tstd::cout << last_node->data << \"\\n\";",
            "\t\tdelete last_node;",
            "\t}",
            "};"
        ],
        "description": "Stack implementation with push and pop methods"
    },
    "HeapSort Function": {
        "prefix": "void heapsort",
        "body": [
            "void heapify(int* arr, int n, int i) {",
            "\tint largest = i;",
            "\tint left = 2 * i + 1;",
            "\tint right = 2 * i + 2;",
            "",
            "\tif (left < n && arr[left] > arr[largest])",
            "\t\tlargest = left;",
            "",
            "\tif (right < n && arr[right] > arr[largest])",
            "\t\tlargest = right;",
            "",
            "\tif (largest != i) {",
            "\t\tstd::swap(arr[i], arr[largest]);",
            "\t\theapify(arr, n, largest);",
            "\t}",
            "}",
            "",
            "void heapsort(int* arr, int n) {",
            "\tfor (int i = n / 2 - 1; i >= 0; i--)",
            "\t\theapify(arr, n, i);",
            "",
            "\tfor (int i = n - 1; i > 0; i--) {",
            "\t\tstd::swap(arr[0], arr[i]);",
            "",
            "\t\theapify(arr, i, 0);",
            "\t}",
            "}"
        ],
        "description": "HeapSort implementation with heapify function"
    }
}